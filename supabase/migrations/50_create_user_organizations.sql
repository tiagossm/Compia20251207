-- Create user_organizations table for N-to-N relationship
CREATE TABLE IF NOT EXISTS public.user_organizations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, -- Assuming auth.users or public.users. Using public.users based on existing code context
    organization_id BIGINT NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'viewer', -- 'org_admin', 'manager', 'inspector', 'viewer'
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(user_id, organization_id)
);

-- Add index for performance
CREATE INDEX IF NOT EXISTS idx_user_orgs_user_id ON public.user_organizations(user_id);
CREATE INDEX IF NOT EXISTS idx_user_orgs_org_id ON public.user_organizations(organization_id);

-- Migrate existing data from users table
-- We check for conflict to avoid duplicates if run multiple times
INSERT INTO public.user_organizations (user_id, organization_id, role, is_primary)
SELECT 
    id as user_id, 
    organization_id, 
    role, 
    TRUE as is_primary 
FROM 
    public.users 
WHERE 
    organization_id IS NOT NULL
ON CONFLICT (user_id, organization_id) DO UPDATE 
SET is_primary = TRUE; -- Ensure existing relation is primary

-- Security: RLS Policies (if RLS is enabled on tables)
-- For now, we assume application logic handles permissions via tenant-auth-middleware, 
-- but RLS is good practice.
ALTER TABLE public.user_organizations ENABLE ROW LEVEL SECURITY;

-- Policy: Users can see their own memberships
CREATE POLICY "Users can view own memberships" 
ON public.user_organizations 
FOR SELECT 
USING (auth.uid() = user_id);

-- Policy: System Admins can manage all
-- (Assuming public.users has is_active/role)
-- This might require a complex join policy, skipping for now to rely on API middleware.
